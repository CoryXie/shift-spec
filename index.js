function id(x) { return x; }

exports.default = function (primitive, node, listNode, maybeNode, listMaybeNode) {
  if (primitive == null) primitive = id;
  if (node == null) node = id;
  if (listNode == null) listNode = id;
  if (maybeNode == null) maybeNode = id;
  if (listMaybeNode == null) listMaybeNode = id;
  return {
    __proto__: null,
    ArrayBinding: [listMaybeNode("elements"), maybeNode("restElement")],
    ArrayExpression: [listMaybeNode("elements")],
    ArrowExpression: [listNode("parameters"), maybeNode("restParameter"), node("body")],
    AssignmentExpression: [primitive("operator"), node("binding"), node("expression")],
    BinaryExpression: [primitive("operator"), node("left"), node("right")],
    BindingIdentifier: [node("name")],
    BindingPropertyIdentifier: [node("binding"), maybeNode("init")],
    BindingPropertyProperty: [node("name"), node("binding")],
    BindingWithDefault: [node("binding"), node("init")],
    Block: [listNode("statements")],
    BlockStatement: [node("block")],
    BreakStatement: [maybeNode("label")],
    CallExpression: [node("callee"), listNode("arguments")],
    CatchClause: [node("binding"), node("body")],
    ClassDeclaration: [node("name"), maybeNode("super"), listNode("elements")],
    ClassElement: [primitive("isStatic"), node("method")],
    ClassExpression: [maybeNode("name"), maybeNode("super"), listNode("elements")],
    ComputedMemberExpression: [node("object"), node("expression")],
    ComputedPropertyName: [node("expression")],
    ConditionalExpression: [node("test"), node("consequent"), node("alternate")],
    ContinueStatement: [maybeNode("label")],
    DataProperty: [node("name"), node("expression")],
    DebuggerStatement: [],
    Directive: [primitive("rawValue")],
    DoWhileStatement: [node("body"), node("test")],
    EmptyStatement: [],
    Export: [node("declaration")],
    ExportAllFrom: [primitive("moduleSpecifier")],
    ExportDefault: [node("body")],
    ExportFrom: [listNode("namedExports"), primitive("moduleSpecifier")],
    ExportSpecifier: [maybeNode("name"), node("exportedName")],
    ExpressionStatement: [node("expression")],
    ForInStatement: [node("left"), node("right"), node("body")],
    ForOfStatement: [node("left"), node("right"), node("body")],
    ForStatement: [maybeNode("init"), maybeNode("test"), maybeNode("update"), node("body")],
    FunctionBody: [listNode("directives"), listNode("statements")],
    FunctionDeclaration: [primitive("isGenerator"), node("name"), listNode("parameters"), maybeNode("restParameter"), node("body")],
    FunctionExpression: [primitive("isGenerator"), maybeNode("name"), listNode("parameters"), maybeNode("restParameter"), node("body")],
    Getter: [node("name"), node("body")],
    IdentifierExpression: [node("name")],
    IfStatement: [node("test"), node("consequent"), maybeNode("alternate")],
    Import: [maybeNode("defaultBinding"), listNode("namedImports"), primitive("moduleSpecifier")],
    ImportNamespace: [maybeNode("defaultBinding"), node("namespaceBinding"), primitive("moduleSpecifier")],
    ImportSpecifier: [maybeNode("name"), node("binding")],
    LabeledStatement: [node("label"), node("body")],
    LiteralBooleanExpression: [primitive("value")],
    LiteralInfinityExpression: [],
    LiteralNullExpression: [],
    LiteralNumericExpression: [primitive("value")],
    LiteralRegExpExpression: [primitive("pattern"), primitive("flags")],
    LiteralStringExpression: [primitive("value")],
    Method: [primitive("isGenerator"), node("name"), listNode("parameters"), maybeNode("restParameter"), node("body")],
    Module: [listNode("items")],
    NewExpression: [node("callee"), listNode("arguments")],
    NewTargetExpression: [],
    ObjectBinding: [listNode("properties")],
    ObjectExpression: [listNode("properties")],
    PostfixExpression: [node("operand"), primitive("operator")],
    PrefixExpression: [primitive("operator"), node("operand")],
    ReturnStatement: [maybeNode("expression")],
    Script: [node("body")],
    Setter: [node("name"), node("parameter"), node("body")],
    ShorthandProperty: [node("name")],
    SpreadElement: [node("expression")],
    StaticMemberExpression: [node("object"), primitive("property")],
    StaticPropertyName: [primitive("value")],
    Super: [],
    SwitchCase: [node("test"), listNode("consequent")],
    SwitchDefault: [listNode("consequent")],
    SwitchStatement: [node("discriminant"), listNode("cases")],
    SwitchStatementWithDefault: [node("discriminant"), listNode("preDefaultCases"), node("defaultCase"), listNode("postDefaultCases")],
    TemplateElement: [primitive("rawValue")],
    TemplateExpression: [maybeNode("tag"), listNode("elements")],
    ThisExpression: [],
    ThrowStatement: [node("expression")],
    TryCatchStatement: [node("body"), node("catchClause")],
    TryFinallyStatement: [node("body"), maybeNode("catchClause"), node("finalizer")],
    VariableDeclaration: [primitive("kind"), listNode("declarators")],
    VariableDeclarationStatement: [node("declaration")],
    VariableDeclarator: [node("binding"), maybeNode("init")],
    WhileStatement: [node("test"), node("body")],
    WithStatement: [node("object"), node("body")],
    YieldExpression: [maybeNode("expression")],
    YieldGeneratorExpression: [node("expression")],
  };
};
